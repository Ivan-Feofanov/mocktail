package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"go/importer"
	"go/token"
	"go/types"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/ettle/strcase"
)

const (
	srcMockFile    = "mock_test.go"
	outputMockFile = "mock_gen_test.go"
)
const contextType = "context.Context"

// PackageDesc represent a package.
type PackageDesc struct {
	Imports    map[string]struct{}
	Interfaces []InterfaceDesc
}

// InterfaceDesc represent an interface.
type InterfaceDesc struct {
	Name    string
	Methods []*types.Func
}

func main() {
	modulePath, err := getModulePath()
	if err != nil {
		log.Fatal("get module path", err)
	}

	moduleName, err := getModuleName(modulePath)
	if err != nil {
		log.Fatal("get module name", err)
	}

	model, err := walk(modulePath, moduleName)
	if err != nil {
		log.Fatal("walk", err)
	}

	if len(model) == 0 {
		return
	}

	err = testifyWay(model)
	if err != nil {
		log.Fatal("testifyWay", err)
	}
}

//nolint:gocognit,gocyclo // The complexity is expected.
func walk(modulePath, moduleName string) (map[string]PackageDesc, error) {
	root := filepath.Dir(modulePath)

	model := make(map[string]PackageDesc)

	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || d.Name() != srcMockFile {
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}

		packageDesc := PackageDesc{Imports: map[string]struct{}{}}

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := scanner.Text()
			if line == "" {
				continue
			}

			pkgName, err := filepath.Rel(root, filepath.Dir(path))
			if err != nil {
				return err
			}

			i := strings.Index(line, "// mocktail:")
			if i <= -1 {
				continue
			}

			name := line[i+len("// mocktail:"):]

			importPath := moduleName + "/" + pkgName

			fileSet := token.NewFileSet()

			pkg, err := importer.ForCompiler(fileSet, "source", nil).Import(importPath)
			if err != nil {
				return fmt.Errorf("failed to import %q: %w", importPath, err)
			}

			lookup := pkg.Scope().Lookup(name)
			if lookup == nil {
				log.Printf("Unable to find: %s", name)
				continue
			}

			interfaceDesc := InterfaceDesc{Name: name}

			interfaceType := lookup.Type().Underlying().(*types.Interface)

			for i := 0; i < interfaceType.NumMethods(); i++ {
				method := interfaceType.Method(i)

				interfaceDesc.Methods = append(interfaceDesc.Methods, method)

				signature := method.Type().(*types.Signature)

				imports := getTupleImports(signature.Params())
				imports = append(imports, getTupleImports(signature.Results())...)

				for _, imp := range imports {
					if imp != "" && imp != moduleName+"/"+pkgName {
						packageDesc.Imports[imp] = struct{}{}
					}
				}
			}

			packageDesc.Interfaces = append(packageDesc.Interfaces, interfaceDesc)
		}

		if len(packageDesc.Interfaces) > 0 {
			model[path] = packageDesc
		}

		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("walk dir: %w", err)
	}

	return model, nil
}

func getTupleImports(tuple *types.Tuple) []string {
	var imports []string

	for i := 0; i < tuple.Len(); i++ {
		imports = append(imports, getTypeImports(tuple.At(i).Type())...)
	}

	return imports
}

func getTypeImports(t types.Type) []string {
	switch v := t.(type) {
	case *types.Basic:
		return []string{""}

	case *types.Slice:
		return getTypeImports(v.Elem())

	case *types.Map:
		imports := getTypeImports(v.Key())
		imports = append(imports, getTypeImports(v.Elem())...)
		return imports

	case *types.Named:
		if v.Obj().Pkg() == nil {
			return []string{""}
		}

		return []string{v.Obj().Pkg().Path()}

	case *types.Pointer:
		return getTypeImports(v.Elem())

	case *types.Interface:
		return []string{""}

	default:
		panic(fmt.Sprintf("OOPS %[1]T %[1]s", t))
	}
}

//nolint:funlen,gocognit,gocyclo,maintidx // The complexity is expected.
func testifyWay(model map[string]PackageDesc) error {
	for path, descPkg := range model {
		buffer := bytes.NewBufferString("")
		writer := &Writer{writer: buffer}

		pkg := filepath.Base(filepath.Dir(path))

		writer.Println("// Code generated by mocktail; DO NOT EDIT.")
		writer.Println()
		writer.Printf("package %s\n\n", pkg)

		writer.Println("import (")

		for _, imp := range quickGoImports(descPkg) {
			if imp == "" {
				writer.Println(imp)
			} else {
				writer.Printf("\t%q\n", imp)
			}
		}

		writer.Println(")")
		writer.Println()

		for _, interfaceDesc := range descPkg.Interfaces {
			structBaseName := strcase.ToGoCamel(interfaceDesc.Name)

			writer.Printf(`
// %[2]sMock mock of %[3]s.
type %[2]sMock struct { mock.Mock }

func new%[1]sMock(tb testing.TB) *%[2]sMock {
	tb.Helper()

	m := &%[2]sMock{}
	m.Mock.Test(tb)

	tb.Cleanup(func() { m.AssertExpectations(tb) })

	return m
}
`, strcase.ToGoPascal(interfaceDesc.Name), structBaseName, interfaceDesc.Name)

			writer.Println()

			for _, method := range interfaceDesc.Methods {
				writer.Printf("func (_m *%sMock) %s(", structBaseName, method.Name())

				signature := method.Type().(*types.Signature)

				var argsNames string
				for i := 0; i < signature.Params().Len(); i++ {
					param := signature.Params().At(i)

					var ignored bool
					if param.Type().String() == contextType {
						writer.Print("_")
						ignored = true
					} else {
						writer.Print(param.Name())
						argsNames += param.Name()
					}

					writer.Print(" " + getTypeName(pkg, param.Type()))

					if i+1 < signature.Params().Len() {
						writer.Print(", ")
						if !ignored {
							argsNames += ", "
						}
					}
				}

				writer.Print(") ")

				if signature.Results().Len() > 1 {
					writer.Print("(")
				}

				for i := 0; i < signature.Results().Len(); i++ {
					writer.Print(getTypeName(pkg, signature.Results().At(i).Type()))
					if i+1 < signature.Results().Len() {
						writer.Print(", ")
					}
				}

				if signature.Results().Len() > 1 {
					writer.Print(")")
				}

				writer.Println(" {")

				writer.Print("\t")
				if signature.Results().Len() > 0 {
					writer.Print("_ret := ")
				}
				writer.Printf("_m.Called(%s)\n", argsNames)

				for i := 0; i < signature.Results().Len(); i++ {
					if i == 0 {
						writer.Println()
					}

					rType := signature.Results().At(i).Type()

					writer.Printf("\t_r%s%d", string(rune('a'+i)), i)

					switch rType.String() {
					case "string", "int", "bool", "error":
						writer.Printf("\t := _ret.%s(%d)\n", strcase.ToPascal(rType.String()), i)
					default:
						name := getTypeName(pkg, rType)
						writer.Printf(", _ := _ret.Get(%d).(%s)\n", i, name)
					}
				}

				for i := 0; i < signature.Results().Len(); i++ {
					if i == 0 {
						writer.Println()
						writer.Print("\treturn ")
					}

					writer.Printf("_r%s%d", string(rune('a'+i)), i)

					if i+1 < signature.Results().Len() {
						writer.Print(", ")
					} else {
						writer.Println()
					}
				}

				writer.Println("}")
				writer.Println()

				// ---

				writer.Printf("func (_m *%sMock) On%s(", structBaseName, method.Name())

				for i := 0; i < signature.Params().Len(); i++ {
					param := signature.Params().At(i)

					if param.Type().String() == contextType {
						continue
					}

					writer.Print(param.Name())
					writer.Print(" " + getTypeName(pkg, param.Type()))

					if i+1 < signature.Params().Len() {
						writer.Print(", ")
					}
				}

				writer.Printf(") *%s%sCall {\n", structBaseName, method.Name())

				writer.Printf(`	return &%s%sCall{Call: _m.Mock.On("%s", %s)}`, structBaseName, method.Name(), method.Name(), argsNames)
				writer.Println()
				writer.Println("}")
				writer.Println()

				// ---

				writer.Printf("func (_m *%sMock) On%sRaw(", structBaseName, method.Name())

				var rawArgNames []string
				for i := 0; i < signature.Params().Len(); i++ {
					param := signature.Params().At(i)

					if param.Type().String() == contextType {
						continue
					}

					writer.Print(param.Name())
					writer.Print(" interface{}")
					rawArgNames = append(rawArgNames, param.Name())

					if i+1 < signature.Params().Len() {
						writer.Print(", ")
					}
				}

				writer.Printf(") *%s%sCall {\n", structBaseName, method.Name())
				writer.Printf(`	return &%s%sCall{Call: _m.Mock.On("%s"`, structBaseName, method.Name(), method.Name())
				if len(rawArgNames) > 0 {
					writer.Printf(`, %s`, strings.Join(rawArgNames, ", "))
				}
				writer.Print(")}")
				writer.Println()
				writer.Println("}")
				writer.Println()

				// ---

				writer.Printf("type %s%sCall struct{ *mock.Call }\n\n", structBaseName, method.Name())

				// ---

				if signature.Results().Len() > 0 {
					writer.Printf("func (_c %s%sCall) TypedReturns(", structBaseName, method.Name())

					var returnNames string
					for i := 0; i < signature.Results().Len(); i++ {
						rName := string(rune(int('a') + i))

						writer.Printf("%s %s", rName, getTypeName(pkg, signature.Results().At(i).Type()))
						returnNames += rName

						if i+1 < signature.Results().Len() {
							writer.Print(", ")
							returnNames += ", "
						}
					}

					writer.Println(") *mock.Call {")
					writer.Printf("\treturn _c.Return(%s)\n", returnNames)
					writer.Println("}")
					writer.Println()
				}
			}
		}

		if writer.err != nil {
			return writer.err
		}

		// gofmt
		source, err := format.Source(buffer.Bytes())
		if err != nil {
			log.Println(buffer.String())
			return fmt.Errorf("source: %w", err)
		}

		out := filepath.Join(filepath.Dir(path), outputMockFile)

		log.Println(out)

		err = os.WriteFile(out, source, 0o640)
		if err != nil {
			return fmt.Errorf("write file: %w", err)
		}
	}

	return nil
}

func quickGoImports(descPkg PackageDesc) []string {
	imports := []string{"testing", "", "github.com/stretchr/testify/mock"}
	for imp := range descPkg.Imports {
		imports = append(imports, imp)
	}

	sort.Slice(imports, func(i, j int) bool {
		if imports[i] == "" {
			return strings.Contains(imports[j], ".")
		}
		if imports[j] == "" {
			return !strings.Contains(imports[i], ".")
		}

		if strings.Contains(imports[i], ".") && !strings.Contains(imports[j], ".") {
			return false
		}
		if !strings.Contains(imports[i], ".") && strings.Contains(imports[j], ".") {
			return true
		}

		return imports[i] < imports[j]
	})

	return imports
}

func getTypeName(pkg string, t types.Type) string {
	switch v := t.(type) {
	case *types.Basic:
		return v.Name()

	case *types.Slice:
		return "[]" + getTypeName(pkg, v.Elem())

	case *types.Map:
		return "map[" + getTypeName(pkg, v.Key()) + "]" + getTypeName(pkg, v.Elem())

	case *types.Named:
		i := strings.LastIndex(v.String(), "/")
		if i <= -1 {
			return v.String()
		}

		name := v.String()[i+1:]
		if v.Obj().Pkg().Name() == pkg {
			name = name[len(pkg)+1:]
		}

		return name

	case *types.Pointer:
		return "*" + getTypeName(pkg, v.Elem())

	case *types.Interface:
		return v.String()

	default:
		panic(fmt.Sprintf("OOPS %[1]T %[1]s", t))
	}
}

// Writer is a wrapper around Print+ functions.
type Writer struct {
	writer io.Writer
	err    error
}

// Err returns error from the other methods.
func (w *Writer) Err() error {
	return w.err
}

// Print formats using the default formats for its operands and writes to standard output.
func (w *Writer) Print(a ...interface{}) {
	if w.err != nil {
		return
	}

	_, w.err = fmt.Fprint(w.writer, a...)
}

// Printf formats according to a format specifier and writes to standard output.
func (w *Writer) Printf(pattern string, a ...interface{}) {
	if w.err != nil {
		return
	}

	_, w.err = fmt.Fprintf(w.writer, pattern, a...)
}

// Println formats using the default formats for its operands and writes to standard output.
func (w *Writer) Println(a ...interface{}) {
	if w.err != nil {
		return
	}

	_, w.err = fmt.Fprintln(w.writer, a...)
}
